#include <bits/stdc++.h>#include "pqueue.h"using namespace std;ostream& operator<<(ostream& os, PQueue &dt) {  os << "Afisam coada cu prioritati\n";  for(int i = 0; i < dt.getSize(); ++i) {    QueInfo tmp = dt.with_lazy(i);    os << tmp.val << ' ' << tmp.priority << '\n';    }  os << '\n';  return os;  }void PairVector::reserve(int nc) {  // aloca un vector de dimensiune nc  QueInfo *aux = new QueInfo[nc];  for(int i = 0; i < N; ++i)    aux[i] = v[i];  capacity = nc;  //delete[] v;  v = new QueInfo[nc];  for(int i = 0; i < N; ++i)    v[i] = aux[i];  }int PairVector::size() {  return N;  }bool PairVector::empty() {  return N == 0;  }void PairVector::push_back(QueInfo x) {  if(N == capacity) {    capacity *= 2;    reserve(capacity);    }  assert(N < capacity);  v[N++] = x;  /*/  daca avem in total lungimea n facem 1 + 2 + 4 + ... + 2^log2n operati=2*n=O(n)  deci O(n) pt n insertii/*/  }void PairVector::pop_back() {  N--;  }QueInfo PairVector::back() {  if(empty())    return QueInfo(-1, -1);  return v[N - 1];  }void PairVector::operator=(const PairVector &that) {  N = that.N, capacity = that.capacity;  if(capacity > 0) {    v = new QueInfo[capacity];    for(int i = 0; i < capacity; ++i)      v[i] = that.v[i];    }  }int PQueue::getSize() {  return que.size();  }void PQueue::add(QueInfo x, bool merging) {  x.priority -= lazy;  que.push_back(x);  if(merging) return ;  int j = que.size() - 1;  while(j > 0 && realPrio(j) > realPrio(j - 1)) {    swap(que[j], que[j - 1]);    --j;    }  }void PQueue::remove(int x) {  for(int i = 0; i < que.size(); ++i) {    if(que[i].val == x) {      for(int j = i + 1; j < que.size(); ++j) que[j - 1] = que[j];      que.pop_back();      return;      }    }  }int PQueue::maxPriority() {  return que[0].priority + lazy;  }int PQueue::maxValue() {  int best = numeric_limits<int>::min();  for(int i = 0; i < que.size(); ++i)    best = max(best, que[i].val);  return best;  }int PQueue::realPrio(int at) {  return lazy + que[at].priority;  // returneaza prioritatea adevarata  }void PQueue::operator++() {  lazy++;  // putem incrementa tot cu 1 in O(1)  }void PQueue::operator--() {  lazy--;  while(que.size() - 1 >= 0 && !realPrio(que.size() - 1)) {    que.pop_back();    }  // mereu vom avea sortat dupa prioritati deci cele cu 0 vor fi la final  // pt x stergeri vom avea O(x)  }QueInfo PQueue::with_lazy(int at) {  QueInfo curr = que[at];  curr.priority += lazy;  // returneaza ce e pe pozitia at dar cu prioritate adevarata  return curr;  }PQueue PQueue::operator+(PQueue that) {  PQueue sum;  int i(0), j(0);  //  while(i < getSize() && j < that.getSize()) {    if(realPrio(i) > that.realPrio(j))      sum.add(with_lazy(i++), 1);    else sum.add(that.with_lazy(j++), 1);    }  while(i < getSize()) sum.add(with_lazy(i++), 1);  while(j < that.getSize()) sum.add(that.with_lazy(j++), 1);  // interclasam , vom avea tot sortat dupa prioritati descrescator  // facem in O(size + that.size)  return sum;  }int main() {  PQueue A, B;  srand(time(0));  A.add(QueInfo(7, 1), 0);  A.add(QueInfo(2, 1), 0);  B = A;  A = A + B;  cout << 3 << endl;  ++A;  cout << A.maxValue() << '\n';  assert(A.maxValue() == 7);  A.add(QueInfo(15, 15), 0);  assert(A.maxValue() == 15);  cout << A.maxValue() << '\n';  A.add(QueInfo(9, 1), 0);  cout << A.maxValue() << '\n';  --A;  cout << A;  A.add(QueInfo(-1, 50), 0);  -- A;  --A;  int localMax = 0, LIM = 12345;  /*?  adaugam mai multe elemente ca sa verificam ca nu da crash la adaugari multe/*/  for(int q = 0; q < 5000; ++q) {    int now = rand() % LIM + 1;    assert(now > 0);    // sa nu inseram cu prioritatea 0    localMax = max(localMax, 2 * now);    A.add(QueInfo(2 * now, now), 0);    }  assert(A.maxValue() == localMax);  for(int i = 0; i < localMax; ++i)    --A;  A = A + A;  assert(!A.getSize());  // acum ar trebui sa fie gol  A.add(QueInfo(9, 10), 0);  for(int q = 0; q < 10; ++q)    A = A + A;  assert(A.getSize() == (1 << 10));  }